## Quick Revision Version

### Providers
- Plugins to interact with cloud/service.
- Defines which platform Terraform will manage.
- Use `provider` block + optional `required_providers`.
- Initialize with `terraform init`.
- Why: multi-cloud, multi-account support, ensures correct plugin.
- Common errors: missing credentials, wrong region, version mismatch.
- Fix: check credentials, provider version, region.
- Best Practices: lock provider version, use profiles, consistent config.

### Resources
- Define infrastructure objects: EC2, S3, VPC, subnets.
- Declarative management; ensures desired state.
- Attributes, arguments, meta-arguments (`depends_on`, `count`, `for_each`).
- Lifecycle rules: `create_before_destroy`, `prevent_destroy`.
- Why: automate infra, reduce manual errors, maintain consistency.
- Common errors: missing attributes, dependency conflicts, lifecycle misconfig.
- Fix: check docs, plan before apply, adjust lifecycle.
- Best Practices: modularize, review plan, clear naming.

### Multi-Profile Usage
- Switch accounts/environments via AWS CLI profiles.
- Provider block references profile variable.
- Dynamic switching: `terraform apply -var='aws_profile=qa'`.
- Why: manage Dev/QA/UAT/Prod, avoid hardcoding credentials.
- Common errors: wrong profile, missing creds, env conflicts.
- Fix: verify credentials, use correct variable, unset conflicting env vars.
- Best Practices: dynamic variables, secure creds, document profiles, test before prod.

---

---

## Quick Revision Version

### Concept / What:
- Define, provision, update, and delete infrastructure resources declaratively with Terraform.
- Resources include EC2, S3, VPCs, subnets, databases, GitHub repos, etc.

### Why / Purpose / Use Case in Real-World:
- Automates multi-environment infrastructure provisioning.
- Ensures consistent setups across team and environments.
- Enables version control and reduces human error.
- Supports safe collaboration and change tracking.

### How it Works / Steps / Syntax:
1. Define resource type, name, and attributes in `.tf` file.
2. Run `terraform init` to prepare working directory.
3. Run `terraform plan` to preview changes.
4. Run `terraform apply` to provision/update resources.
5. Modify `.tf` files and rerun plan/apply for updates.
6. Run `terraform destroy` to remove resources.
7. Optional: Use `terraform refresh` or `terraform import` for syncing or importing existing resources.

### Common Issues / Errors:
- Missing attributes.
- Incorrect dependencies.
- Drift from manual changes.
- Live resource conflicts.

### Troubleshooting / Fixes:
- Always check `terraform plan` before applying.
- Define explicit dependencies with `depends_on`.
- Sync state with `terraform refresh`.
- Import manually created resources when needed.

### Best Practices / Tips:
- Modularize and reuse resources.
- Use clear and consistent naming.
- Version control `.tf` files.
- Avoid manual changes; sync if necessary.
- Test in Dev/QA before Prod.
- Apply lifecycle rules carefully.

---
## Quick Revision Version

### Concept / What:
- Arguments: user inputs defining resource creation.
- Attributes: output values generated by Terraform after creation.
- Meta-Arguments: special instructions controlling Terraform’s behavior with resources.

### Why / Purpose / Use Case in Real-World:
- Arguments: define resource configuration.
- Attributes: dynamically reference outputs between resources.
- Meta-Arguments: manage dependencies, multiple instances, and lifecycle behavior.
- Ensures predictable and scalable infrastructure.

### How it Works / Steps / Syntax:
1. Define resource with arguments in `.tf` file.
2. Use `count` / `for_each` / `depends_on` / `lifecycle` as needed.
3. Run `terraform plan` to preview.
4. Run `terraform apply` to provision.
5. Reference generated attributes in other resources or outputs.

### Common Issues / Errors:
- Attribute referenced before creation.
- Index/key errors with `count`/`for_each`.
- Circular dependencies.
- Provider override misconfiguration.

### Troubleshooting / Fixes:
- Inspect plan and attributes before apply.
- Validate syntax for `count`/`for_each`.
- Use `terraform graph` for dependency visualization.
- Ensure correct provider configuration.

### Best Practices / Tips:
- Reference attributes dynamically.
- Parameterize arguments for multiple environments.
- Use meta-arguments only when necessary.
- Avoid circular dependencies.
- Document meta-argument usage clearly.

---

# Terraform Lifecycle Rules / Meta-Arguments - Quick Revision Version

## Concept / What
Lifecycle arguments are Terraform **meta-arguments** that control how resources are managed (create, update, delete). They do not define resources themselves but modify Terraform's behavior.

## Why / Purpose / Use Case
- Protect critical resources from accidental deletion (`PreventDestroy`).
- Ensure high availability by creating new resources before deleting old ones (`CreateBeforeDestroy`).
- Allow certain attributes to drift when changed externally (`IgnoreChanges`).

## How / Steps / Syntax
```hcl
resource "aws_instance" "web" {
  ami = "ami-12345678"
  instance_type = "t2.micro"

  lifecycle {
    prevent_destroy = true
    create_before_destroy = true
    ignore_changes = [instance_type]
  }
}
```
- `PreventDestroy` → blocks accidental deletion.
- `CreateBeforeDestroy` → ensures zero downtime.
- `IgnoreChanges` → ignores drift on selected attributes.

### Drift Handling
- Use `terraform refresh` to sync state with infrastructure.
- `ignore_changes` keeps specified attributes safe from overwriting.

## Common Issues
- Misusing `ignore_changes` expecting automatic reversion.
- Conflicts with `create_before_destroy` if dependencies are incorrect.
- Plan failure when `prevent_destroy` blocks required replacement.

## Troubleshooting
- Always run `terraform plan` to preview changes.
- Use `terraform show` to verify ignored attributes.
- Adjust resource dependencies to avoid conflicts.

## Best Practices
- Apply lifecycle rules only when needed.
- Document ignored attributes for team clarity.
- Combine `prevent_destroy` with backup strategies.
- Review `terraform plan` carefully before applying.
---

## ⚡ Quick Revision Version

### Concept / What:
- **Data sources** = read-only lookups in Terraform.
- Fetch existing infra (not created in current config).

### Why / Purpose:
- Reuse existing infra → no duplication.
- Avoid hardcoding → dynamic references.
- Multi-team collaboration (infra + app teams).
- Example: fetch VPC, AMI, Security Groups.

### How / Syntax:
```hcl
data "aws_ami" "ubuntu" {
  most_recent = true
  owners      = ["099720109477"]
}
```
→ Use `data.aws_ami.ubuntu.id` in resources.

### Common Issues:
- Wrong filters → no match.
- IAM permission errors.
- Region mismatch.
- Cross-account access denied.

### Troubleshooting:
- Verify filters via CLI.
- Add correct IAM policies.
- Use `terraform plan` + `output`.

### Best Practices:
- Always use data sources for IDs/AMIs.
- Use vars + data sources for env portability.
- Debug with outputs before resource usage.

---

